{"pageProps":{"post":{"title":"Philosophers","date":"2023-03-11T20:02:48.279Z","slug":"philosophers","author":{"name":"Amine Beihaqi","picture":"/Logo.svg"},"content":"<h1>Philosophers: Threads, Mutexes, and the Art of Dining</h1>\n<h2>Introduction</h2>\n<p>Welcome to the world of philosophers, where the pursuit of wisdom becomes a deadly dance of threads and mutexes. In this project, you'll delve into the basics of threading a process, creating threads, and mastering mutexes. Are you ready to guide philosophers through the complex ritual of dining while avoiding the grim specter of starvation?</p>\n<h2>Common Instructions</h2>\n<p>Before we unravel the philosophy of dining, let's revisit some common instructions applicable to all projects:</p>\n<ul>\n<li>Your implementation must be in C.</li>\n<li>Adhere to the Norm, including bonus files/functions in the norm check.</li>\n<li>Functions should not quit unexpectedly, and memory leaks are strictly forbidden.</li>\n<li>Include a Makefile with essential rules: <code>$(NAME)</code>, <code>all</code>, <code>clean</code>, <code>fclean</code>, and <code>re</code>.</li>\n<li>Separate bonus parts in <code>_bonus.{c/h}</code> if not specified otherwise.</li>\n<li>If your project allows the use of <code>libft</code>, include its sources and Makefile in a <code>libft</code> folder.</li>\n</ul>\n<h2>Overview: Philosophical Dining</h2>\n<p>In this section, we'll explore the dining rituals of philosophers, uncovering the intricacies of their interaction and the rules that govern their existence. Get ready to thread through the philosophical landscape!</p>\n<h2>Global Rules</h2>\n<p>Your mission, should you choose to accept it, is to write two programs: one for the mandatory part and another for the bonus part (if you're feeling adventurous). Both must adhere to the following rules:</p>\n<ul>\n<li>Global variables are strictly forbidden.</li>\n<li>Accept the following command-line arguments:\n<ul>\n<li><code>number_of_philosophers</code>: The number of philosophers and forks.</li>\n<li><code>time_to_die</code>: Time for a philosopher to die if they haven't eaten.</li>\n<li><code>time_to_eat</code>: Time for a philosopher to eat.</li>\n<li><code>time_to_sleep</code>: Time a philosopher spends sleeping.</li>\n<li><code>[number_of_times_each_philosopher_must_eat]</code>: Optional argument to specify when the simulation stops.</li>\n</ul>\n</li>\n</ul>\n<h3>Logging Rules</h3>\n<ul>\n<li>Any state change of a philosopher must be formatted as follows:\n<ul>\n<li><code>timestamp_in_ms X has taken a fork</code></li>\n<li><code>timestamp_in_ms X is eating</code></li>\n<li><code>timestamp_in_ms X is sleeping</code></li>\n<li><code>timestamp_in_ms X is thinking</code></li>\n<li><code>timestamp_in_ms X died</code></li>\n</ul>\n</li>\n</ul>\n<h3>Safety First!</h3>\n<ul>\n<li>A message announcing a philosopher's death should be displayed no more than 10 ms after the actual death.</li>\n</ul>\n<h2>Mandatory Part: Threads, Forks, and Philosophers</h2>\n<h3>Program Name: philo</h3>\n<p>Your journey begins with threads, forks, and philosophers. Each philosopher is a thread, and forks are your precious resources. Protect the forks' state with mutexes to avoid duplication.</p>\n<h2>Bonus Part: Processes, Semaphores, and the Ultimate Challenge</h2>\n<h3>Program Name: philo_bonus</h3>\n<p>If you've mastered the mandatory part perfectly, it's time to embrace the bonus challenge. Philosophers are now processes, forks are semaphores, and the main process remains a wise observer.</p>\n<h2>Conclusion</h2>\n<p>As you embark on this philosophical journey, remember: no global variables, protect your resources, and guide philosophers through the intricate dance of life and death. May your threading and mutexes be flawless, and philosophers always avoid the fate of starvation!</p>","ogImage":{"url":"/assets/projects/dynamic-routing/1337.jpeg"},"coverImage":"/assets/projects/dynamic-routing/1337.jpeg"}},"__N_SSG":true}